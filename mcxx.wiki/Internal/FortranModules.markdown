
 [[PageOutline]]

Fortran modules are commonly implemented using an external file.


        ! Causes a m.mod file be created
        MODULE M
          ...
        END MODULE M


        USE m; ! Causes a m.mod file be searched

`mf95` compiler used to implement this creating an ancillay file `m.mf95` (or `m.mf95ss` in mf95ss) in the same directory (or choosen by a command-line parameter). Some users have reported that generating an additional file breaks their build systems (given that a new file pops up unexpectedly and may cause directory files cluttering, not sure though about the exact problem).

It is mandatory to generate some sort of external file because modules allow Fortran program units to share declarations so these declarations must be "remembered" from one program unit to another. If the program unit is in the same file then there is no need for an external file but if the module is defined in one file and use in another file (in different program units, not by means of `INCLUDE` trickeries) then that second file needs to retrieve the declarations of the module. In this case a mechanism to retrieve such information is necessary.

## Transparent module support

There are two options to implement a transparent module support. The foremost feature of such a transparent module support is
 
 * no more files should be generated in the build directory other than those that would be generated by the native Fortran compiler

### Parallel global repository

The idea is mirroring the names of the native compiler names with mf03 modules in a hidden directory (usually `$HOME/.mf03-modules` or set by a command-line parameter).

For instance if the file used/generated by the native Fortran compiler is `a/path/to/file/m.mod` the compiler could use `$HOME/.mf03-modules/a/path/to/file/m.mf03`. This is similar to the mf95 approach but with two important differences:

 * the ancillary file is kept in a global repository
 * the ancillary file mirrors the path of the real module file

With this solution the compiler needs to know where (and the order) in which the directories are searched by the native compiler when looking for a module file.

Pros:
 * We do not pollute the builddir as we used to do with mf95. mf95 allowed a directory to be specified to create .mf95 files but would not work in build systems where a same module name is used in different directories (e.g. two modules called `m` generated in different paths and only one is used). This case is a bit convoluted but users tend to do this when they have several implementations of the same interfaces
 * If needed, the native compiler can be called as the native module files are left untouched

Cons:
 * The global repository works as _add only_ since nobody (but a knowledgeable user) can safely remove the files created
 * We are cluttering another directory. This is a bit like keeping dust under the carpet. The problem is not fully solved but hidden in a convenient way

### Embedded native module files

This approach is more complex and fragile. The key idea is keeping all the time mf03 modules as if they were native modules and replace them when the native compiler might need them.

 * When a module `m` is created, the frontend will tell the driver that a new module `m` will be generated.
 * The driver will eventually invoke the native compiler. The native compiler will generate a native `m.mod`.
 * Now the driver will generate a mf03 module and embed the native `m.mod`
 * Finally the mf03 module is stored with the same path of `m.mod` (this is a mf03 module)

 * When using a module `m`, the frontend will tell the driver to look for a module `m` in the directories searched by the native compiler. 
 * If the file is found (and it is a mf03 module) load it and proceed.
 * The driver will eventually invoke the native compiler. The native compiler will keep a copy of the mf03 `m.mod` and extract from it the native compiler module, overwriting the mf03 `m.mod` with a native `m.mod`.
 * Finally the driver will overwrite the native module with the mf03 one.

In this strategy we end with `.mod` files which are not native but mf03.

Pros:
 * Fully transparent if Mercurium driver is used all the time

Cons:
 * Complex and fragile
 * The native compiler cannot be invoked directly as the stored modules will not be native. Maybe this is not a problem since when we usually invoke by hand the native compiler for linking issues, not a moment where modules are used.
 * Replacing and overwriting files may fool timestamp based build systems (like make or CMake) which may rebuild more files than expected (or get into a loop) in the case where a rule depends on a `.mod` file. We could restore the `mtime` of the file and it would probably work except for "parallel make" scenarios which might be confused by the file juggling.

## Module cache

`mf95` suffered from several design flaws leading to exponential build times. While some of these problems have been addressed in the latests `mf95ss` versions it is worth mentioning a module cache during compilation.

If a module is defined in the same file as it is used there is no need to open the module from the filesystem. Each file will have a cache module as we can safe assume that inside a same file all references to a same module-name will resolve to the same module (this might not be 100% true between files). When a module is defined in a file it will be added in a cache so further uses of this module in the same file will use the cached symbol.

If a used module is not in the cache, once loaded it will be added to it, so further references to a module will use that cache.

This simple cache strategy may imply dramatic compilation time improvements in big Fortran applications which use lots of modules.

## A module is just a set of symbols

In contrast to what mf95 and mf95ss do, the code of the module is not stored in a .mf95 file, nor parsed again (when the module is used) nor kept in the tree. A module is just a symbol with a set of related symbols which can be imported by means of a USE.