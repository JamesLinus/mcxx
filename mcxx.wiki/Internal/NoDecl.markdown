
 NoDecl aims at simplifying the trees of Fortran and C++ so they can be easily analyzed later.

## Simplification vs lowering

Note that this process does not aim at lowering the trees into more primitive or low-level constructs but remove syntactical burden which actually is useless and cumbersome to handle.

## Declarations

Any sort of declaration is removed.

 *Rationale:* Declarations are actually unneeded as with a proper link between the tree and the scope we should be able to regenerate them

Both in C/C++ and in Fortran declarations determine attributes of symbols. All these attributes must be stored in the symbol or related symbols and should be enough for regenerate such declarations.

In C/C++ since symbols are declared in a single statement and may be optionally defined later. In Fortran a symbol may have its full declaration scattered in one or more statements. Thus in Fortran, such removal is even more beneficial.

## Routines

Functions and Fortran program units (except Block-Data) will be represented as a common set of routines. Given a routine tree it should be easy to get its symbol, the returning type (although this should be obtainable from the symbol itself as well), a list of parameter symbols and a list of statements. A list of nested routines will be obtainable as well.

## Processing of trees

C/C++ and Fortran parsers generate very high level trees which are processed by `{cxx,fortran03}-buildscope.c` (statements, including declarations) and `{cxx,fortran03}-exprtype.c` (code specific to expressions). Once they have been processed, these trees are free of ambiguities and have all typechecking performed.

These trees can be passed to `{cxx,fortran03}-prettyprint` to get a description of the tree which is really similar to that of the input source.

As mentioned above modifying these trees is cumbersome as it requires extra effort to keep all the declarations in sync with the scope information. Files `{cxx,fortran03}-nodecl.c` implement the conversion from these detailed trees to nodecl trees which are simpler and do not include declarations or anything that could be deduced by querying the scope.

## Grammar definition of NoDecl

 Metasyntax: For brevity, in these rules we use the following metasyntax `X-seq` meaning the following rule
   `X-seq → AST_LIST(X-seq-opt, X)`
 where X is a rule. `X-opt` means 
   `X-opt → X | NULL`
 The right part of the rule will use the syntax `AST_KIND(t0, t1, t2, t3)` to state the tree we can expect being t_i_ the tree generated by the rule or `NULL` otherwise. The rules have an associated value of type `AST` as declared in `cxx-ast.h`. *This set of rules specify the NoDecl language, not the mapping from Fortran/C/C++ to NoDecl*


        nodecl → top-level-seq
        top-level → function-code 
                  | object-init
        
        function-code → AST_FUNCTION_CODE(name, statement-seq, function-code-opt)
        object-init → AST_OBJECT_INIT(name, expression)
        
        statement → AST_EXPRESSION_STATEMENT(expression)
                  | AST_COMPOUND_STATEMENT(statement-seq-opt)
                  | AST_DO_STATEMENT(expression, statement)
                  | AST_WHILE_STATEMENT(expression, statement)
                  | AST_FOR_STATEMENT(loop-control, statement)
                  | AST_IF_ELSE_STATEMENT(expression, statement, statement-opt)
                  | AST_LABELED_STATEMENT(label, statement)
                  | AST_SWITCH_STATEMENT(expression, statement)
                  | AST_DEFAULT_STATEMENT(statement)
                  | AST_CASE_STATEMENT(label, statement)
                  | AST_BREAK_STATEMENT()
                  | AST_CONTINUE_STATEMENT()
                  | AST_GOTO_STATEMENT(label)
                  | AST_RETURN_STATEMENT(expression))
                  | AST_PRAGMA_CUSTOM_CONSTRUCT(AST_PRAGMA_CUSTOM_DIRECTIVE(pragma-line), statement)
                  | AST_PRAGMA_CUSTOM_DIRECTIVE(pragma-line)
                  | c-cxx-only_statements
                  | fortran-only-statements
        
        c-cxx-only-statements → AST_TRY_BLOCK(statement, catch-handler-seq)
        catch-handler → AST_CATCH_HANDLER(name, statement)
        
        
        # FIXME - Document these. Some of them could be simplified further
        fortran-only-statements → AST_ALLOCATE_STATEMENT
                                | AST_ARITHMETIC_IF_STATEMENT
                                | AST_ASSIGNED_GOTO_STATEMENT
                                | AST_CLOSE_STATEMENT
                                | AST_COMPUTED_GOTO_STATEMENT
                                | AST_DEALLOCATE_STATEMENT
                                | AST_IO_STATEMENT
                                | AST_LABEL_ASSIGN_STATEMENT
                                | AST_NULLIFY_STATEMENT
                                | AST_OPEN_STATEMENT
                                | AST_PRINT_STATEMENT
                                | AST_READ_STATEMENT
                                | AST_RETURN_STATEMENT
                                | AST_STOP_STATEMENT
                                | AST_PAUSE_STATEMENT
                                | AST_WRITE_STATEMENT
        
        expression → literal
                   | name
                   | AST_FUNCTION_CALL(name, argument-seq)
                   | AST_ARRAY_SUBSCRIPT(expression, subscript-seq)
                   | AST_CLASS_MEMBER_ACCESS(expression, name)
                   | AST_PLUS(expression)
                   | AST_NEG(expression)
                   | AST_MULT(expression, expression)
                   | AST_POWER(expression, expression)
                   | AST_DIV(expression, expression)
                   | AST_ADD(expression, expression)
                   | AST_MINUS(expression, expression)
                   | AST_CONCAT(expression, expression)
                   | AST_EQUAL(expression, expression)
                   | AST_DIFFERENT(expression, expression)
                   | AST_LOWER_THAN(expression, expression)
                   | AST_LOWER_OR_EQUAL_THAN(expression, expression)
                   | AST_GREATER_THAN(expression, expression)
                   | AST_GREATER_OR_EQUAL_THAN(expression, expression)
                   | AST_NOT(expression)
                   | AST_LOGICAL_AND(expression, expression)
                   | AST_LOGICAL_OR(expression, expression)
                   | AST_COMPLEMENT(expression)
                   | AST_BITWISE_AND(expression, expression)
                   | AST_BITWISE_OR(expression, expression)
                   | AST_BITWISE_XOR(expression, expression)
                   | AST_SHL(expression, expression)
                   | AST_SHR(expression, expression)
                   | AST_ASSIGNMENT(expression, expression)
                   | AST_PARENTHESIZED_EXPRESSION(expression)
                   | c-cxx-expressions
                   | fortran-expressions
        
        subscript → expression
                  | AST_SUBSCRIPT_TRIPLET(expression-opt, expression-opt, expression-opt)
        
        c-cxx-expressions → AST_CONDITIONAL_EXPRESSION(expression, expression, expression)
                          | AST_POINTER_TO_MEMBER(expression, expression)
                          | AST_REFERENCE(expression)
                          | AST_DERREFERENCE(expression)
        
        fortran-expressions → AST_PTR_ASSIGNMENT(expression, expression)