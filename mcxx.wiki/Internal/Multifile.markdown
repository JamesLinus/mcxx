
 Targeting at several architectures in terms of single source compilation.

## Changes in the configuration file

We need several changes in the configuration files to support multifile. Two main changes are needed: *variables* and new *options*.

### New concepts

*Main profile*, is the profile which is called from command line. This profile is special with respect to that we assume:

 * This profile can generate something we can run (currently we are not considering a cross-compiler strategy)
 * Should the compilation process generate files for other profiles, the profile will perform at the end a *combine* phase. This combine phase generates a final object which is the combination of all the objects/executables generated by the other profiles.

*Secondary profiles* are those used indirectly by the main profile. If the main profile creates a file for another profile (other than the main) then each of these profiles are secondary ones. Technically nothing prevents from a secondary profile to invoke other profiles, but we are not targetting at this scenario currently (it might work, though). Each of the secondary profiles _must_ define an *embed* option towards the main profile, in case a void processing was not eligible.

### New variables

We need new variables useable inside the options. Only those options which are meant to be used repeatedly in the compiler will have these
variables properly expanded.

 `$OUTPUT` The output file finally generated. If `-o` is specified, this is, otherwise the name of the generated file

 `$INPUT` The input file (e.g. `.c`, `.cpp`, etc.)

 `$PP_OUTPUT` The output file name generated after preprocessing. If the file does not require preprocessing, this may match `$INPUT`

 `$OBJ_OUTPUT` The output file generated after native compilation

 `$EXE_OUTPUT` The generated executable after the whole processing. Bear in mind that this might not be an executable but a shared library

 `$ALL_OBJECTS` All the objects to be considered just before linking

In the first prototypes this will not be implemented. Instead we will assume the required tools use common flags (like `-o`) to specify the inputs and output files.

### New options


        embed_method = {object|executable}

State the embedding method. What is to be embedded in this profile is either each object or the whole "executable" (here the executable may be a mere collection of .o stored under one file). If `embed_method` is `object`, after each object compiled it will be embedded to the main profile. If `embed_method` is `executable`, the generated executable will be embedded to the main profile.

  *At the moment it is unclear how to implement `executable`, so only `object` will be implemented*


        embed[profile-name] = command

This should be used in secondary profiles to specify how to convert the output (either an object or a full executable) to an object file of the main profile (eligible for linking in the main profile). The user typically will use `$OUTPUT` variable and $`OBJ_OUTPUT` or $`EXE_OUTPUT`.


        combine = command

This command is used by the main profile as a preliminary step before the final file generation. If no files for other profiles are generated, this step is ommitted. If files for other profiles have been generated, this step is used to generate the final object (just before the linking). Typically the user will use `$ALL_OBJECTS` and `$OBJ_OUTPUT` in this command.

## Diagrams

Please check the [diagram in PDF](http://nanos.ac.upc.edu/projects/mcxx/attachment/wiki/Multifile/driver_behaviour.pdf)

![](../../../../files/note/11800/Internal/Multifile/multifile.jpg)