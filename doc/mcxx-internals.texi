\input texinfo
@c %**start of header
@setfilename mcxx-internals.info
@settitle mcxx Internals Manual
@c %**end of header

@copying
mcxx Internals Manual. Version 1.0

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.

Copyright @copyright{} 2007 Roger Ferrer Ib@'a@~nez.
@end copying

@titlepage
@title mcxx Internals Manual
@c The following two commands start the copyright page
@subtitle Mercurium C/C++ Internal Documentation Reference
@subtitle Last modified: $Date$
@author Roger Ferrer Ib@'a@~nez
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents 
@contents

@ifnottex
@node Top
@top mcxx Internals Documentation Reference
@insertcopying
@end ifnottex

@menu
* Introduction::
* Compilation process::
@end menu

@node Introduction
@chapter Introduction
@cindex introduction

@menu
* What is this document about::
* What is mcxx?::
@end menu

@node What is this document about
@section What is this document about
@cindex goal of the document

This is the @acronym{mcxx, Mercurium C++ compiler} internals reference document. This document intends to give the
reader a detailed explanation of the compiler, how it works and how it can be extended.
The idea is not to give a course of compilers but allow any user with enough
compilation process knowledge to modify the compiler.

This is not a document to learn C or C++ and even in some places it requires good
knowledge of these. 

@node What is mcxx?
@section What is mcxx?
@cindex what is mcxx

mcxx is a C/C++ research compiler targeted at source-to-source processing. The word
research here means that it is not intended to be a commercial high-quality compiler
(even if the developers would like it to be) and thus it may crash, eat your homework
or wipe your hard disk. Normally, though, this is unlikely to happen.

This compiler was developed to fill some needs when dealing with C++. There are
not very much C++ compilers open source and none of them@footnote{At the time
of writing this document} was useful for source-to-source processing.
Commercial, or non source-to-source ones, compilers tend to lower as early as
possible to intermediate representations that loose track of almost all the
source so they are not very well suited for this kind of processing. C is
supported as it is almost a subset of C++ and because many things are easier to
do in C than in C++ when concerning to symbolic issues.

The compiler started initially in the context of OpenMP research so
some parts of it are really well suited for it. On the other hand, the
compiler itself is rather generic and has been used in some contexts
not strictly related to OpenMP.

@node Compilation process
@chapter Compilation process
@cindex compilation process

@menu
* Compilation flow overview::
* Driver::
@end menu

In this chapter a global vision of the compilation process and an explanation
about layout of the files and directories is given.

@node Compilation flow overview
@section Compilation flow overview
@cindex compilation flow

@menu
* Preprocessing::
* Context free parsing::
* Semantic analysis::
* Compilation pipeline::
* Prettyprinting::
* Additional steps::
@end menu

The compiler flow can be sketched as follows.

@enumerate
@item First the source code is preprocessed.
@item The preprocessed source is parsed. 
@item The ambiguous tree is then analyzed semantically. 
@item The pipeline of compilation phases is launched. 
@item The modified abstract syntax tree is prettyprinted into a file.
@item Additional steps depending on the exact arguments passed.
@end enumerate

@node Preprocessing
@subsection Preprocessing
@cindex preprocessing

In this phase the input source files are preprocessed using the configured
preprocessor. Normally @command{gcc -E} or @command{cpp} is used.

This step is mandatory since non preprocessed input files can
form incomplete or even invalid source files. The compiler recognizes
location marks left by the GNU-style preprocessor. This information
can be used further by the compiler to know which file the code came from.

The compiler also recognizes @code{#pragma} lines. Note that pragmas are generally
not macro expanded from the preprocessor. This is not a limitation of mcxx
but the way the whole compilation system works.

@node Context free parsing
@subsection Context free parsing
@cindex context free parsing

Once the code has been preprocessed it is parsed. In this step a GLR 
parser@footnote{Currently this parser requires a somewhat special version of @command{bison-2.3}
with support for @code{default-merge} directive. This directive is just
a productivity option to save some writing in the grammar but it does not
add any other functionality not existing in @command{bison-2.3}.} is used.
This parser is built after a somewhat modified standard grammar@footnote{For efficiency reasons
following strictly the C/C++ standard grammar is not feasible, in particular for C++. However, the grammar
is designed to be equivalent to the standard one.} and it accepts C99@footnote{ISO/IEC 9899:1999} and 
C++@footnote{ISO/IEC 14882:2003} syntactically valid applications.

The parser tries to support several syntactic GNU extensions@footnote{mcxx tries hard to
accept anything accepted by GCC 4.1}, mainly the
@code{__attribute__} notation but also some other GNU idioms. Support for this
non-standard extensions normally does not go beyond the parser unless needed
for some later process. Do not expect the compiler to do anything clever with these
extensions.

This phase constructs the @acronym{AST, Abstract Syntax Tree} that will be used
in all the later processes. This step does a completely @emph{context-free}
parsing, so the tree generated here is ambiguous. Being ambiguous has several
drawbacks, mainly the tree is completely useless. It has some benefits too,
allows to realize how deep some ambiguities in C++ (and C, but less) are. These
ambiguities have to be fixed, but fixing them requires contextual knowledge.

Main files involved in this step are @file{src/frontend/cxx-lexer.l},
@file{src/frontend/c99.y.in}, @file{src/frontend/cxx03.y.in}, @file{src/frontend/cxx-construct.y},
@file{src/frontend/cxx-omp.y} and @file{src/frontend/cxx-pragma.y}.

@node Semantic analysis
@subsection Semantic analysis
@cindex semantic analysis

In order to fix the AST generated in the previous phase, we need to gather
symbolic information that will allow us to realize the exact meaning of the
code. 

Doing this process in two steps, first building the tree in the parsing phase
and then pruning it, allows easier maintenance of the grammar (always a tough
part of any generated parser) and simplifies the semantic part (as one has to
deal with syntactic elements always of the same shape). Doing both things at
the same time is possible but is much more complex, on the other hand it saves
memory (now we are wasting memory for all the potential interpretation of
ambiguous parts of the code).

This process builds the scope (symbol tables) information needed for
disambiguation.  The main files involved in this phase are
@file{src/frontend/cxx-buildscope.c} and @file{src/frontend/cxx-ambiguity.c}.

@node Compilation pipeline
@subsection Compilation pipeline
@cindex compilation pipeline

Once the tree has been fixed and symbolic information gathered from the source
the compilation pipeline is started. 

This compilation pipeline is a set of dynamic libraries loaded by the compiler.
The compiler runs every phase sequentially, this phases can do anything to the
code. Normally they modify the AST in order to make changes to the current
code. These phases, as you will have guessed, are customizable to fit
everyone's need. They are written in C++ and the compiler provides some sort of
SDK to do it.

These phases can be used in a sequential fashion, as the data they can compute
can be passed to the next phases. This allows to have separate phases working
on an additional intermediate information, besides the AST and the symbolic
information.

@node Prettyprinting
@subsection Prettyprinting
@cindex prettyprinting

The last step done by the compiler is called prettyprinting. The resulting AST
after the compilation pipeline phase it is prettyprinted into an output file,
or the standard output.

@node Additional steps
@subsection Additional steps
@cindex additional steps

mcxx provides a full fledged driver that is able to invoke the native compiler
and the linker if needed. This allows for easier usage in makefiles.

@node Driver
@section Driver
@cindex driver

The driver code is located exclusively in the files
@file{src/driver/cxx-driver.c}, @file{src/driver/cxx-driver-decls.h} and
@file{src/driver/cxx-driver.h}. It is a command-line application that
handles all the compilation flow described in @ref{Compilation flow overview}.

@menu
* Configuration::
* Extension handling::
@end menu

@node Configuration
@subsection Configuration
@cindex configuration

mcxx is a `configurable' compiler this means that its behaviour can be modified by several
means, the main being the configuration file.

By default, the configuration file is in @file{@emph{pkgdatadir}/config.mcxx}. Directory
@file{@emph{pkgdatadir}} is defined at @command{configure} time and by default it is
@file{/usr/local/mcxx/share}.

This file allows defining several profiles. The profile modifies the compiler behaviour. The
exact profile used when running the compiler can be chosen implicitly, using the basename
of the invocation of the compiler (this is, how it has been named to invoke it) or using
@option{--profile=@emph{name}}. The following is an example of configuration file.

@example
# For C
[mcc]
language = C
options =
preprocessor_name = gcc
preprocessor_options = -E 
compiler_name = gcc
compiler_options = 
linker_name = gcc
linker_options = 
compiler_phase = libtlinstr.so
compiler_phase = libtlomp.so

# For C++
[mcxx]
language = C++
options = 
preprocessor_name = g++
preprocessor_options = -E 
compiler_name = g++
compiler_options = 
linker_name = g++
linker_options = 
compiler_phase = libtlinstr.so
compiler_phase = libtlomp.so
@end example

@node Extension handling
@subsection Extension handling
@cindex extensions

mcxx tries to make sensible choices when concerning extension types.

@bye
