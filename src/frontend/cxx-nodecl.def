
#
#   rule : another-rule
#        | NODECL_TREE_CONSTRUCTOR([child_name] rule-name, ...) options
#
#
# Up to 4 children, [child_name] is mandatory and must be a valid C/C++/Fortran name
#
# options is a blank-separated sequence of the following. Each option-name declares extra
# information that is mandatory to the tree (i.e. it cannot be NULL). 
#
#    option-name               frontend type
#        symbol                    scope_entry_t*
#        type                      type_t*
#        text                      const char*
#        const_value               const_value_t*
#        template-parameters       template_parameter_list_t*
#        context                   decl_context_t
#
# The order that appears here is the order in which this extra information is
# passed (regardless of the precise syntax of the rule, i.e. 'symbol' is always
# considered before 'type')
#
# There is a special rule 'nodecl' which is the root of the whole hierarchy,
# while not enforced every rule should be referenced in another rule. The
# structure must be nonambiguous (i.e. there must be a single way of
# constructing a given hierarchy)
#

nodecl : NODECL_TOP_LEVEL([top_level] top-level-seq-opt)
top-level : function-code 
          | object-init
          | pragma-directive
          | compatibility
          | cxx-decl

name : NODECL_SYMBOL() symbol
type : NODECL_TYPE() type

function-code: regular-function-code
             | template-function-code

internal-function-code: regular-function-code
                      | template-function-code
                      | pragma-declaration

regular-function-code : NODECL_FUNCTION_CODE([statements]context, [initializers]mem-init-seq-opt, [internal_functions]internal-function-code-seq-opt) symbol
template-function-code: NODECL_TEMPLATE_FUNCTION_CODE([statements]context, [initializers]mem-init-seq-opt, [internal_functions]internal-function-code-seq-opt) symbol

object-init : NODECL_OBJECT_INIT() symbol

mem-init: NODECL_MEMBER_INIT([init_expr]expression) symbol
          | cxx-mem-init


statement : statement-but-object-init
          | object-init
          | cxx-decl
          | context
          | function-code

context : NODECL_CONTEXT([in_context] in_context) context

in_context : statement-seq-opt
           | expression

statement-but-object-init: NODECL_EMPTY_STATEMENT()
          | NODECL_EXPRESSION_STATEMENT([nest]expression)
          | compound-statement
          | NODECL_DO_STATEMENT([statement]statement-seq, [condition]expression)
          | NODECL_WHILE_STATEMENT([condition]expression, [statement]statement-seq, [loop_name]name-opt) 
          | NODECL_FOR_STATEMENT([loop_header]loop-control, [statement]statement-seq, [loop_name]name-opt) 
          | NODECL_IF_ELSE_STATEMENT([condition]expression, [then]statement-seq, [else]statement-seq-opt) 
          | NODECL_LABELED_STATEMENT([statement]statement-seq) symbol
          | NODECL_SWITCH_STATEMENT([switch]expression, [statement]statement-seq)
          | NODECL_DEFAULT_STATEMENT([statement]statement-seq)
          | NODECL_CASE_STATEMENT([case]case-expression-seq, [statement]statement-seq)
          | NODECL_BREAK_STATEMENT([construct_name]name-opt)
          | NODECL_CONTINUE_STATEMENT([construct_name]name-opt)
          | NODECL_GOTO_STATEMENT() symbol
          | NODECL_RETURN_STATEMENT([value]expression-opt)
          | pragma-directive
          | pragma-statement
          | c-cxx-only-statements
          | fortran-only-statements
          | parallel-statements
          | compatibility
          | NODECL_ERR_STATEMENT()

compound-statement : NODECL_COMPOUND_STATEMENT([statements]statement-seq-opt, [finally]statement-seq-opt) 

case-expression : expression

loop-control: NODECL_LOOP_CONTROL([init]expression-opt, [cond]expression-opt, [next]expression-opt)
            | NODECL_RANGE_LOOP_CONTROL([lower]expression, [upper]expression, [step]expression-opt) symbol
            | NODECL_UNBOUNDED_LOOP_CONTROL()

pragma-directive: NODECL_PRAGMA_CUSTOM_DIRECTIVE([pragma_line]pragma-line, [context_of_decl]pragma-context) text
                | pragma-declaration

pragma-declaration: NODECL_PRAGMA_CUSTOM_DECLARATION([pragma_line]pragma-line, [nested_pragma]pragma-declaration-opt, [context_of_decl]pragma-context, [context_of_parameters]pragma-context-opt) text symbol

pragma-context : NODECL_PRAGMA_CONTEXT() context

pragma-statement : NODECL_PRAGMA_CUSTOM_STATEMENT([pragma_line]pragma-line, [statements]statement-seq) text

pragma-line: NODECL_PRAGMA_CUSTOM_LINE([parameters]pragma-clause-arg-seq-opt, [clauses]pragma-custom-clause-seq-opt, [end_clauses]pragma-custom-clause-seq-opt) text
pragma-custom-clause: NODECL_PRAGMA_CUSTOM_CLAUSE([arguments]pragma-clause-arg-seq-opt) text
pragma-clause-arg: NODECL_PRAGMA_CLAUSE_ARG() text

c-cxx-only-statements : NODECL_TRY_BLOCK([statement]statement-seq, [catch_handlers]catch-handler-seq-opt, [any]statement-seq-opt)

catch-handler : NODECL_CATCH_HANDLER([name]object-init-opt, [statement]statement-seq) type

literal : NODECL_INTEGER_LITERAL() type const_value
    | NODECL_FLOATING_LITERAL() type const_value
    | NODECL_COMPLEX_LITERAL([real]expression, [imag]expression) type
    | NODECL_BOOLEAN_LITERAL() type const_value
    | string-literal
    | structured-value

string-literal: NODECL_STRING_LITERAL() type const_value
 
expression : literal
           | name
           | context
           | NODECL_FUNCTION_CALL([called] expression, [arguments] argument-seq-opt, [alternate_name]name-opt) type
           | NODECL_ARRAY_SUBSCRIPT([subscripted] expression, [subscripts]expression-seq) type
           | NODECL_RANGE([lower] expression-opt, [upper] expression-opt, [stride] expression) type
           | NODECL_CLASS_MEMBER_ACCESS([lhs]expression, [member]expression) type
           | NODECL_PLUS([rhs]expression) type
           | NODECL_NEG([rhs]expression) type
           | NODECL_MUL([lhs]expression, [rhs]expression) type
           | NODECL_POWER([lhs]expression, [rhs]expression) type
           | NODECL_DIV([lhs]expression, [rhs]expression) type
           | NODECL_MOD([lhs]expression, [rhs]expression) type
           | NODECL_ADD([lhs]expression, [rhs]expression) type
           | NODECL_MINUS([lhs]expression, [rhs]expression) type
           | NODECL_CONCAT([lhs]expression, [rhs]expression) type
           | NODECL_EQUAL([lhs]expression, [rhs]expression) type
           | NODECL_DIFFERENT([lhs]expression, [rhs]expression) type
           | NODECL_LOWER_THAN([lhs]expression, [rhs]expression) type
           | NODECL_LOWER_OR_EQUAL_THAN([lhs]expression, [rhs]expression) type
           | NODECL_GREATER_THAN([lhs]expression, [rhs]expression) type
           | NODECL_GREATER_OR_EQUAL_THAN([lhs]expression, [rhs]expression) type
           | NODECL_LOGICAL_NOT([rhs]expression) type
           | NODECL_LOGICAL_AND([lhs] expression, [rhs] expression) type
           | NODECL_LOGICAL_OR([lhs] expression, [rhs] expression) type
           | NODECL_BITWISE_NOT([rhs]expression) type
           | NODECL_BITWISE_AND([lhs] expression, [rhs] expression) type
           | NODECL_BITWISE_OR([lhs] expression, [rhs] expression) type
           | NODECL_BITWISE_XOR([lhs] expression, [rhs] expression) type
           | NODECL_SHL([lhs] expression, [rhs] expression) type
           | NODECL_SHR([lhs] expression, [rhs] expression) type
           | NODECL_ASSIGNMENT([lhs] expression, [rhs] expression) type
           | NODECL_PARENTHESIZED_EXPRESSION([nest]expression) type
           | NODECL_DERREFERENCE([rhs]expression) type
           | NODECL_CAST([rhs]expression) type text
           | NODECL_COMPOUND_EXPRESSION([nest]context) type
           | c-cxx-expressions
           | fortran-expressions
           | object-init
           | compatibility
           | NODECL_ERR_EXPR()
# This one is intended to represent implicit conversions allowed by the base language
           | NODECL_CONVERSION([nest] expression) type
# This one represents an expression the value of which is already saved in another symbol
           | NODECL_SAVED_EXPR([expression]expression) type symbol

structured-value: NODECL_STRUCTURED_VALUE([items]initializer-item-seq-opt) type

initializer-item: NODECL_FIELD_DESIGNATOR([field]name, [next]initializer-item)
          | NODECL_INDEX_DESIGNATOR([index]expression, [next]initializer-item)
          | expression
          | fortran-implied-do

fortran-implied-do: NODECL_FORTRAN_IMPLIED_DO([name]name, [range]expression, [items]initializer-item-seq)

argument : named-pair
         | expression
         | alt-return

named-pair: NODECL_FORTRAN_NAMED_PAIR_SPEC([name]name-opt, [argument]expression)

alt-return: NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT() symbol type

c-cxx-expressions : NODECL_CONDITIONAL_EXPRESSION([condition]expression, [true]expression, [false]expression) type
                  | NODECL_REFERENCE([rhs]expression) type
                  | NODECL_COMMA([rhs]expression, [lhs]expression) type
                  | NODECL_THROW([rhs]expression-opt) type
                  | NODECL_VIRTUAL_FUNCTION_CALL([called] expression, [arguments] argument-seq) type
                  | NODECL_MUL_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_DIV_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_ADD_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_MINUS_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_SHL_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_SHR_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_BITWISE_AND_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_BITWISE_OR_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_BITWISE_XOR_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_MOD_ASSIGNMENT([lhs] expression, [rhs] expression) type
                  | NODECL_PREINCREMENT([rhs]expression) type
                  | NODECL_POSTINCREMENT([rhs]expression) type
                  | NODECL_PREDECREMENT([rhs]expression) type
                  | NODECL_POSTDECREMENT([rhs]expression) type
                  | NODECL_SIZEOF([size_type]type, [expr]expression-opt) type
                  | NODECL_ALIGNOF([align_type]type) type
                  | NODECL_OFFSET([base]expression, [offset]expression) type
                  | NODECL_TYPEID([arg]type-or-expr) type
                  | NODECL_NEW([init]expression-opt, [placement]expression-seq-opt, [alloc_func]name-opt) type text
                  | NODECL_DELETE([rhs]expression) type
                  | NODECL_DELETE_ARRAY([rhs]expression) type
                  | NODECL_POINTER_TO_MEMBER() symbol type
                  | NODECL_REAL_PART([rhs]expression) type
                  | NODECL_IMAG_PART([rhs]expression) type
                  | NODECL_OFFSETOF([offset_type]type, [designator]cxx-dependent-initializer-seq) type
                  | NODECL_SHAPING([postfix] expression, [shape] expression-seq) type
                  | NODECL_PSEUDO_DESTRUCTOR_NAME([accessed] expression, [destructor_name] cxx-dependent-name) type
                  | cxx-expr-dependent-nodecls
                  | cuda-expressions

# This is only for dependent parts of C++. These nodecls exist because
# usual nodecls may not retain enough semantic information for a successful
# instantiation. These nodecls should never appear in the code (but may be accessible
# through symbols for instantiation purposes)
cxx-expr-dependent-nodecls: cxx-dependent-name
   | cxx-dependent-initializer
   | cxx-dependent-expressions

# nodecl was created entirely to avoid this kind of "declaration nodes" but we
# will not be able to get rid of them until we instantiate template functions
cxx-decl : NODECL_CXX_DECL() symbol
    | NODECL_CXX_DEF() symbol
    | NODECL_CXX_EXPLICIT_INSTANTIATION([declarator_name] cxx-dependent-name-opt, [context] context) symbol
    | NODECL_CXX_EXTERN_EXPLICIT_INSTANTIATION([declarator_name] cxx-dependent-name-opt, [context] context) symbol

# Special nodes for dependent names
cxx-dependent-name : NODECL_CXX_DEP_GLOBAL_NAME_NESTED([items] cxx-atom-dependent-name-seq)
                   | NODECL_CXX_DEP_NAME_NESTED([items] cxx-atom-dependent-name-seq)
                   | cxx-atom-dependent-name
cxx-atom-dependent-name : cxx-simple-name
                   | NODECL_CXX_DEP_TEMPLATE_ID([name]cxx-atom-dependent-name) text template-parameters
                   | NODECL_CXX_DEP_NAME_CONVERSION([context] context)

cxx-simple-name: NODECL_CXX_DEP_NAME_SIMPLE() text

cxx-dependent-initializer : NODECL_CXX_BRACED_INITIALIZER([init]expression-seq-opt)
    | NODECL_CXX_EQUAL_INITIALIZER([init]expression)
    | NODECL_CXX_PARENTHESIZED_INITIALIZER([init]expression-seq-opt)
    | NODECL_C99_DESIGNATED_INITIALIZER([designation]cxx-dependent-initializer-seq, [init]expression)
    | NODECL_C99_FIELD_DESIGNATOR([name]cxx-simple-name)
    | NODECL_C99_INDEX_DESIGNATOR([expr]expression) 

# a->b
cxx-dependent-expressions: NODECL_CXX_ARROW([lhs]expression, [member]expression) type
# a.*b
    | NODECL_CXX_DOT_PTR_MEMBER([lhs]expression, [ptr]expression) type
# a->*b
    | NODECL_CXX_ARROW_PTR_MEMBER([lhs]expression, [ptr]expression) type
# sizeof(expr)
    | NODECL_CXX_SIZEOF([expr] expression) type
# alignof(expr)
    | NODECL_CXX_ALIGNOF([expr] expression) type
# (type) { ... }
    | NODECL_CXX_POSTFIX_INITIALIZER([postfix]expression) type
# a[e:e]
    | NODECL_CXX_ARRAY_SECTION_RANGE([postfix] expression, [lower] expression-opt, [upper] expression-opt, [stride] expression-opt) type
# a[e;e]
    | NODECL_CXX_ARRAY_SECTION_SIZE([postfix] expression, [start] expression-opt, [num_items] expression-opt, [stride] expression-opt) type
# T(expr-list)
    | NODECL_CXX_EXPLICIT_TYPE_CAST([init_list]cxx-dependent-initializer) type

# id-expr(expr) in a member initializer
cxx-mem-init: NODECL_CXX_MEMBER_INIT([name]cxx-dependent-name, [initializer]expression) type

cuda-expressions : NODECL_CUDA_KERNEL_CALL([kernel_config] expression-seq, [function_call] expression) type

type-or-expr : type
             | expression

fortran-only-statements : NODECL_FORTRAN_ALLOCATE_STATEMENT([items]expression-seq, [options]fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT([expr]expression, [lower]name, [equal]name, [upper]name)
                        | NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT([index]name, [label_seq]name-seq)
                        | NODECL_FORTRAN_OPEN_STATEMENT([io_items] fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_CLOSE_STATEMENT([io_items] fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT([label_seq]name-seq, [index] expression)
                        | NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT([index] expression)
                        | NODECL_FORTRAN_DEALLOCATE_STATEMENT([items]expression-seq, [options]fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_IO_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt) text
                        | NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT([value]expression, [label_var]name)
                        | NODECL_FORTRAN_NULLIFY_STATEMENT([items]expression-seq)
                        | NODECL_FORTRAN_PRINT_STATEMENT([format] expression, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_READ_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_WRITE_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_STOP_STATEMENT([stop_code]expression-opt)
                        | NODECL_FORTRAN_PAUSE_STATEMENT([pause_code]expression-opt)
                        | NODECL_FORTRAN_ENTRY_STATEMENT() symbol
                        | NODECL_FORTRAN_WHERE([where_set] where-pair-seq)
                        | NODECL_FORTRAN_FORALL([loop_control] loop-control-seq, [mask] expression-opt, [statement] statement-seq)

where-pair: NODECL_FORTRAN_WHERE_PAIR([mask] expression-opt, [statement] statement-seq)

# NODECL_FORTRAN_DATA
#   This is used only for .data variable which holds the initializations by means
#   of DATA statements
# NODECL_FORTRAN_EQUIVALENCE
#   This is used only for .equivalence variable which holds the equivalence of
#   data storage
fortran-expressions : NODECL_FORTRAN_DATA([objects]fortran-data-item-seq, [values]fortran-data-item-seq)
                    | NODECL_FORTRAN_EQUIVALENCE([first]expression, [second]expression-seq)
                    | NODECL_FORTRAN_BOZ_LITERAL() type text const_value

fortran-data-item : expression
                  | fortran-implied-do

fortran-io-spec: NODECL_FORTRAN_IO_SPEC([value]expression-opt) text

fortran-io-item : expression
           | fortran-implied-do

compatibility: unknown-pragma
          | source-comment
          | preprocessor-text
          | verbatim
          | asm-definition
          | gcc-asm-definition
          | gcc-asm-spec
          | upc-sync-statement
          | gcc-builtin-va-arg
          | gxx-traits
          | text

gcc-builtin-va-arg: NODECL_GCC_BUILTIN_VA_ARG([expr] expression, [va_type]type) type

asm-definition : NODECL_ASM_DEFINITION([asm_text]text-seq)

unknown-pragma : NODECL_UNKNOWN_PRAGMA() text
source-comment: NODECL_SOURCE_COMMENT() text
preprocessor-text : NODECL_PREPROCESSOR_LINE() text
verbatim: NODECL_VERBATIM() text

gcc-asm-spec : NODECL_GCC_ASM_SPEC() text

gcc-asm-definition : NODECL_GCC_ASM_DEFINITION([operands0]gcc-asm-operand-seq-opt, [operands1]gcc-asm-operand-seq-opt, [operands2]gcc-asm-operand-seq-opt, [specs]text-seq-opt) text
gcc-asm-operand : NODECL_GCC_ASM_OPERAND( [identifier]text-opt, [constraint]text, [expr]expression-opt)

upc-sync-statement : NODECL_UPC_SYNC_STATEMENT([expr]expression) text

gxx-traits: NODECL_GXX_TRAIT([lhs]type, [rhs]type-opt) text type

text : NODECL_TEXT() text

##############################
# Parallelism (ongoing work) #
##############################

parallel-statements : parallel-execution
                    | synchronization

parallel-execution : async-execution
                   | single-execution
                   | exclusive-execution
                   | replicated-execution
                   | distributed-execution
                   | atomic-execution
                   | composited-execution

# single
single-execution : NODECL_PARALLEL*SINGLE([environment]exec-environment-seq-opt, [statements]statement-seq-opt)

# critical
exclusive-execution : NODECL_PARALLEL*EXCLUSIVE([environment]exec-environment-seq-opt, [statements]statement-seq-opt)

# inline task
async-execution : NODECL_PARALLEL*ASYNC([environment]exec-environment-seq-opt, [statements]statement-seq-opt) 
                | async-call

# function task
async-call : NODECL_PARALLEL*ASYNC_CALL([environment]exec-environment-seq-opt, [call]expression)

# Futures?
# expression : async-call

exec-environment : NODECL_PARALLEL*CONDITION([condition]expression)
                 | NODECL_PARALLEL*CAPTURE([captured_symbols]name-seq)
                 | NODECL_PARALLEL*SHARED([shared_symbols]name-seq)
                 | NODECL_PARALLEL*PRIVATE([private_symbols]name-seq)
                 | NODECL_PARALLEL*REDUCTION([reductions]async-reduction-seq)
                 | NODECL_PARALLEL*DEP_IN([in_deps]expression-seq)
                 | NODECL_PARALLEL*DEP_OUT([out_deps]expression-seq)
                 | NODECL_PARALLEL*DEP_INOUT([inout_deps]expression-seq)
                 | NODECL_PARALLEL*COPY_IN([input_copies]expression-seq)
                 | NODECL_PARALLEL*COPY_OUT([output_copies]expression-seq)
                 | NODECL_PARALLEL*COPY_INOUT([inout_copies]expression-seq)
                 | NODECL_PARALLEL*SCHEDULE([chunk]expression-opt) text
# Not yet decided
                 | NODECL_PARALLEL*TARGET()
                 | NODECL_PARALLEL*PRIORITY([priority]expression)
                 | NODECL_PARALLEL*UNTIED()
                 | NODECL_PARALLEL*CRITICAL_NAME() text
                 | NODECL_PARALLEL*BARRIER_AT_END()

async-reduction : NODECL_PARALLEL*REDUCTION_ITEM([reductor]name, [reduced_symbol]name)

# parallel
replicated-execution : NODECL_PARALLEL*REPLICATE([environment]exec-environment-seq-opt, [num_replicas]expression-opt, [statements]statement-seq)

# for
distributed-execution : NODECL_PARALLEL*DISTRIBUTE([environment]exec-environment-seq-opt, [ranges]distribute-range-seq, [statements]statement-seq)
distribute-range : NODECL_PARALLEL*DISTRIBUTE_RANGE([lower]expression, [upper]expression, [step]expression) symbol

# atomic
atomic-execution : NODECL_PARALLEL*ATOMIC([name]name-opt, [statements]statement-seq)

# sections
composited-execution : NODECL_PARALLEL*COMPOUND([environment]exec-environment-seq-opt, [regions]statement-seq)

synchronization : NODECL_PARALLEL*WAIT_ASYNCS_DEPENDENCES([environment]exec-environment-seq-opt)
# First level of async
                | NODECL_PARALLEL*WAIT_ASYNCS_SHALLOW()
# All levels of async
                | NODECL_PARALLEL*WAIT_ASYNCS_DEEP()
                | NODECL_PARALLEL*FLUSH_MEMORY([expressions] expression-seq-opt)
# Full barrier
                | NODECL_PARALLEL*BARRIER_FULL()
# First half of a barrier (signaling phase)
                | NODECL_PARALLEL*BARRIER_SIGNAL()
# Second half of a barrier (waiting phase)
                | NODECL_PARALLEL*BARRIER_WAIT()
